# 第二章

C++面对对象的三大特征：封装、继承、多态

## 2.1类与对象

### 1.类与对象

类是创建对象的模板，对象是类的实例。类是抽象的，不占用内存空间，对象是具象的，占用内存空间。

```C++
class 类名{
    public:
    	公有成员数据和成员函数;
    private:
    	私有成员数据和成员函数;    
};
```

一般先写public后写private，让调用者更关注public部分。

struct的成员访问权限默认是public的，class的成员访问权限默认是private的



### 2.成员函数

成员函数可以使用类里的任何成员（无论是什么public、protected还是private）

公有成员函数可以被外部调用，私有成员函数不可以被外部调用，只能被类里的其他成员函数调用。

成员函数可以在类里定义，也可以在类外定义（通常用类外定义）。成员函数如果在类外定义，则需要先在类里写函数声明，后在类外定义。要用 “**类名::**” 来声明函数是属于哪个类的。

```C++
class A{
    public:
    	void display1(){
            cout<<a;
        }
    	void display2();
    private:
    	int a;    
};
void A::display2(){
    cout<<a;
}
```



### 3.类的封装性

1. public：允许类内外的任何访问。
2. protected：只允许类成员和派生类成员访问。
3. private：只允许类成员访问。

**接口与实现分离：**

student.h头文件里放类的声明，student.cpp文件里放类成员函数的定义。

student.cpp和main.cpp都要#include student.h，然后分别编译student.cpp和main.cpp得到student.o和main.o，再将他们链接起来得到可执行文件。



### 4.构造函数

类的数据成员只能通过构造函数初始化，创建类的对象时系统自动执行构造函数。

构造函数名与类名相同，没有返回类型和返回值。如果用户不写构造函数，系统自动生成一个空的构造函数。

构造函数可以不带参数，也可以带参数。这些构造函数的参数个数或者类型不同，就是构造函数的重载。

```C++
class Time{
    public:
    	Time();
    	Time(int);
    private:
    	int hour,minute;
};
Time::Time(){
    hour=0;
}
Time::Time(int h){
    hour=h;
}
```

参数初始化列表方法：不在函数体内进行初始化，在函数首部直接初始化。

```C++
Time::Time(int h,int m):hour(h),minute(m){
}
```

可以在构造函数声明时指定默认参数，如果全部参数都指定了默认值，则调用时可以不传参。也可以依旧传参，传几个参数则替换前面的几个参数，后面的参数还是用默认参数。

一般不应同时使用构造函数的重载和构造函数的默认参数，可能会有冲突。



### 5.析构函数

类名前加一个 ~  ，在对象生命周期结束时自动执行。

不同类型的对象生命周期结束的时机：

1. 函数中的局部对象：函数调用结束时
2. static局部对象 or 全局对象：main函数结束或者exit时
3. 用new方法创建的对象：用delete释放该对象时。

析构函数是对象释放内存前执行的，主要用来做收尾的清理工作，比如对象通过new占用的内存空间，要delete释放回去。

如果用户不编写析构函数，编译系统会自动生成一个空的析构函数。



### 6.静态数据成员

某个类的所有对象共享一个单一的存储空间，这些对象之间可以通过这个静态数据成员变量进行相互通信。

静态数据成员的定义必须出现在类的外部且只能定义一次。一般是在.h文件里类内部声明静态数据成员，在.cpp文件中定义。这样即使头文件被多个cpp文件包含也不会导致重复定义。

```c++
//xxx.h
class Base{
    public:
    	static int var;
};
//xxx.cpp
int Base::var=1;
```

派生类的对象也共享基类的静态数据成员。

静态数据成员不属于某一个对象，因此计算对象占用的内存空间时不包含其中的静态数据成员。静态数据成员是在所有对象之外单独开辟一段空间来存放。即使不定义对象，也能够直接通过类名引用这个静态数据成员（Base::var）。

静态数据成员在程序编译时分配空间，在程序结束时释放空间，与对象的创建和撤销无关。



### 7.静态成员函数

静态成员函数也是可以通过类名或者对象名来引用：

```C++
class Base{
    public:
    	static int volume();
};
//通过类名引用静态成员函数
Base::volume();
//通过对象引用静态成员函数
Base b;
b.volume();
```

静态成员函数不属于任何对象，他没有this指针，只能访问本类中的静态数据成员（这就是他唯一的作用）

普通的成员函数也可以访问静态数据成员，静态成员函数的好处是方便一点，处理静态数据成员时不用生成对象就能调用。



### 8.对象的内存占用计算

空类生成的实例占1B。

非空类生成的实例占用的内存空间 = 非静态数据成员的内存占用的总和（注意对齐）

> 类中成员函数不占用内存空间，类中如果有虚函数，则需要一个8B大小的指针来指向虚函数表 



### 9.this指针

类的多个对象共用函数代码段，那么不同对象的成员函数引用数据成员时如何保证引用的是对应对象的数据成员呢？

事实上每个成员函数中都包含一个this指针，它的值是此成员函数所属对象的起始地址，然后就可以按照this指针来寻找对象的数据成员。this指针是隐式使用的，作为参数被传递给成员函数。this在调用成员函数时构造，在成员函数结束时清除。

```C++
//表面上
int Box::volumn(){
    return h*w*l;
}
Box b;
b.volumn();
//实际上
int Box::volumn(Box *this){
    return (this->h)*(this->w)*(this->l);
}
Box b;
b.volumn(&b);
```



### 10.类模板

作用跟函数模板差不多。就是多个类的功能相同，但是数据成员的数据类型不同，就可以用到类模板。

```C++
template<class T>
class Operation{
    public:
    	Operation(T a,T b):x(a),y(b){}
    	T add(){
            return x+y;
        }
    	T subtract();
   	private:
    	T x,y;
}
T Operation<T>::subtract(){
    return x-y;
}


Operation <int> op_int(1,2);
op_int.add();

Operation <double> op_double(1,2);
op_double.add();
```



### 11.构造函数和析构函数的执行顺序

存储类别、生命周期相同的情况下的对象，**先构造的后析构，后构造的先析构**，像一个栈一样后进先出。



## 2.2继承与派生

### 1.派生

派生类在继承基类的数据成员和成员函数的情况下，再加上自己的新内容。

派生类会继承基类的所有内容，这样多次派生后可能会有许多无用数据。

```C++
class 派生类名:继承方式 基类名{
  	派生类新增成员
};
```



### 2.派生类的访问属性

基类成员函数无法访问派生类的成员，派生类成员函数可以访问基类的成员。

基类成员在派生类中的访问属性要考虑：

1. 基类成员本身的访问属性（public、protected、private）
2. 派生类对基类的继承方式（public、protected、private）

不同继承方式只会影响基类的public和protected成员的访问属性，不会影响private的访问属性，派生类无论如何都访问不到基类的private成员。

1. **public继承**：基类的public和protected成员访问属性不变。
2. **protected继承**：基类的public和protected成员都成为**protected**的（即不能被外界引用，只能被自己或派生类引用）
3. **private继承**：基类的public和protected成员都变成**private**的。

实际中一般用public继承，否则多次派生后会很混乱。



### 3.派生类的构造函数和析构函数

1. 派生类中对基类和子对象成员的初始化必须在构造函数的初始化列表中进行。新增成员的初始化可以在初始化列表或者函数体中进行。
2. 构造函数执行顺序为：基类构造函数、子对象构造函数、派生类的构造函数。
3. 如果基类的构造函数不带参数，则可以省略初始化列表中调用基类构造函数；如果基类的构造函数带参数，则必须在初始化列表中调用基类构造函数以提供基类数据成员初始化所需的参数。

```C++
class CStudent{
    public:
    	CStudent(string s){
            name=s;
        }
    	~CStudent(){}
    protected:
    	string name;
};

class CStudent1:public Cstudent{
  	public:
    	Cstudent1(string s,int a):CStudent(s){
            age=a;
        }
    	~CStudent1(){}
    private:
    	int age;
};
```

派生类不能继承基类的析构函数。派生类要定义自己的析构函数来处理自己的清理工作，而基类成员的清理工作仍然由基类的析构函数处理。



### 4.派生类的构造函数和析构函数的调用次序

构造函数执行顺序为：基类构造函数（追溯到最源头的基类的构造函数）、子对象构造函数、派生类的构造函数。

析构函数执行顺序则恰恰相反。跟栈的后进先出机制一样。



## 2.3 类的多态

### 1.多态（虚函数）

多态：具有不同功能的函数使用同一个函数名（用同一个函数名调用不同内容的函数）

多个对象调用同一个函数，而他们可以各自用自己的方式去响应。

函数重载是指函数名相同，但是参数类型或者个数不同。

而多态情况下，派生类和基类中存在名字和参数形式都相同的函数。

虚函数的作用：允许在派生类中重新定义与基类同名的函数。虚函数是多态的基础，没有虚函数就无法实现多态特性。

```C++
class A{
    public:
    	virtual void foo(){
            cout<<"A";
        }
};
class B:public A{
    public:
    	virtual void foo(){
            cout<<"B";
        }
};

A a;
a.foo();//输出A
B b;
b.foo();//输出B

//将成员函数定义为虚函数，就能使得基类对象的指针变量既可以访问基类的虚函数，也可以访问派生类的虚函数。
A *pt=&a;
pt->foo();//输出A
pt=&b;  //此时基类指针指向的是派生类对象中的基类部分，且派生类的虚函数替代了基类部分的虚函数
pt->foo();//输出B
```

多态性：对同一消息，不同对象有不同的响应方式。

当一个成员函数被声明为虚函数后，其派生类中的同名函数都自动成为虚函数。在派生类中再次声明此虚函数时，一般加上virtual会更好（也可以不加）。

### 2.虚函数的使用

使用虚函数的情况：

1. 成员函数所在类会成为基类，且该成员函数在类的继承后有可能被更改功能。
2. 定义虚函数可以是空的，留给派生类实现。

当一个类带有虚函数时，编译系统会为该类构造一个虚函数表（指针数组），存放每个虚函数的入口地址。



### 3.纯虚函数

纯虚函数在基类中只声明不定义，而在派生类中必须要定义。纯虚函数就是声明后面加上 =0 。

```C++
virtual void foo()=0;
```

拥有纯虚函数的类成为抽象类，这个类不能实例化，否则会报错。



### 4.析构函数

构造函数不可以声明为虚函数，析构函数可以声明为虚函数。



### 5.单例模式

单例类特征：

1. 有一个指向唯一实例的静态指针，且是private的；
2. 有一个public的函数可以获取这个唯一的实例（如果未创建则创建出一个实例）
3. 类的构造函数是私有的，用户只能通过上面那个public的函数来创建实例。

```C++
class A{
    public:
    	static A *GetInstance(){
            if(pInstance==NULL){
                pInstance=new A();
            }
            return pInstance;
        }
    private:
    	static A * pInstance;
    	A(){}
};
A* A::pInstance=NULL;

int main(){
    A *p1=A::GetIndtance();
    A *p2=A::GetIndtance();
 	if(p1==p2){
        cout<<"same";
    }
}
```

