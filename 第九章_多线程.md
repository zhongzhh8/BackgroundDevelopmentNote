# 第九章

没有线程之前，多个进程一起参与调度，竞争CPU、内存等系统资源，每次进程切换，都存在进程资源的保存和恢复操作，这也叫上下文切换。进程频繁切换引起的额外开销影响系统性能，且进程间通信实现复杂。因此需要引入线程的概念。

同一个进程内部可以有多个线程，它们共享进程的所有资源，从而支持同一个应用程序内部的并发，不仅免去了进程频繁切换的开销，而且线程间通信更简单。

本章内容大多数讲的都是函数原型和具体的例子，这里只是做简略概括一下，具体还是要看书本。

## 9.1

略

## 9.2 多线程的创建和结束

### 1、创建线程

多线程编程需要包括头文件：

```C++
#include <pthread.h>
```

pthread_create是线程创建函数：

```cpp
int pthread_create(指向线程标识符的指针，线程属性，线程运行函数的起始地址，运行函数的参数)
```

pthread_join函数用来等待一个线程的结束，并接收返回值。

pthread_exit用来结束线程，并传递返回值。这个返回值由pthread_join接收。（这个函数是子线程调用的，其他两个是主线程调用的）

### 2、向线程传递参数

pthread_create函数的最后一个参数就是用来给线程传递参数的，如果要传递多个变量，需要用结构体包装起来才能传参。

### 3、获得线程id

两种方式：

1. 主线程在创建线程时，pthread_create函数调用完毕后，其第一个参数的指针就是子线程的id。
2. 在子线程中调用pthread_self函数也可以得到线程id。



## 9.3 线程的属性

创建线程时可以指定其属性。线程的属性有很多，比如栈地址、栈大小、线程优先级等，其中书本这个章节讲的最多的是“分离状态”这个属性。

分离状态：若线程终止时，线程处于分离状态，则系统不保留其状态。如此则pthread_join得不到线程的结束状态信息，会报错。

创建线程时可以指定线程为分离状态，除此之外也可以使用pthread_detach函数设置线程为分离状态。



## 9.4 多线程同步

### 1、多线程同步问题

多线程共享同一个资源，容易造成超卖等问题。

如果程序运行的结果依赖于不同线程执行的先后顺序，就会造成竞争条件问题。最常见的解决方法就是将原本分离的几个指令合并成一个不可分割的原子操作。

解决多线程同步的方法有：

- 互斥锁
- 条件变量
- 读写锁
- 信号量

### 2、互斥锁

就是mutex，跟王道的操作系统书的进程同步部分一样。

主要是两个函数pthread_mytex_lock和pthread_mytex_unlock，其中mutex变量是全局变量（才能被多个线程函数访问到）。

### 3、条件变量

条件变量与互斥锁的区别：

- 互斥锁：所有线程不断的检查mutex，直到临界资源空闲，线程得到互斥锁。
- 条件变量：线程检查mutex，发现锁被占据后，进入阻塞状态。直到条件变量被其他线程改变后，通知并唤醒其中一个被这个条件变量阻塞的线程。

用pthread_cond_init初始化条件变量，用pthread_cond_wait等待条件（必须配合互斥锁，防止多个线程同时请求pthread_cond_wait），用pthread_cond_signal唤醒一个等待该条件的线程。

惊群效应：每当有资源可用时，所有进程/线程都来竞争资源。

条件变量适合多个线程等待某个条件的发生，如果不使用条件变量，那么每个线程都不断尝试获得互斥锁来检查条件是否发生，会消耗大量系统资源。

### 4、读写锁

读写锁对应读者写者问题，是指允许多个读者同时读，但是只允许一个写者同时写。

同样一个mutex，读者用pthread_rwlock_rdlock获取mutex，写者用pthread_rwlock_wrlock获取mutex。二者都用pthread_rwlock_unlock释放mutex。

### 5、信号量

互斥锁只允许一个线程进入临界区，信号量允许多个线程进入临界区。其实就是王道OS书里的PV操作，经典题目。这里跳过。



## 9.5 多线程重入

可重入函数：可以由多个任务并发使用，而不必担心数据错误的函数。

不可重入函数：只能由一个任务占用，除非能确保函数的互斥。