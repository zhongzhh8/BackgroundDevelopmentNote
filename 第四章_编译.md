# 第四章

执行编译命令 **g++ a.cpp**后得到可执行文件**a.out**，执行a.out就能运行程序。这个编译过程实际上包括四个步骤：预处理、编译、汇编、链接。

## 4.1编译与链接

**a.cpp**—(预处理)—> **a.i** —(g++编译)—> **a.s** —(as汇编)—> **a.o** —(链接)—> **a.out**



### 1.预处理

```bash
g++ -E a.cpp -o a.i
```

-E选项只执行到预处理，直接输出预处理后的结果文件。

预处理过程处理那些以“#”开始的预编译指令（#include   #define  #ifdef等）

1. 删除所有#define，展开所有宏定义。比如 #define a b   就是把程序中所有a用b替换。
2. 处理所有条件预编译指令，比如#ifdef  #endif 等，决定编译程序对哪些代码进行处理，过滤掉其他代码（比如调试输出语句）。
3. 处理#include预编译指令，将被include的头文件插入到预编译指令的位置（递归进行）。采用头文件的目的主要是让某些定义（变量、类、函数）可以供多个不同的cpp程序调用而不是重复书写。
4. 过滤掉注释的语句。



### 2.编译

```bash
g++ -S a.i -o a.s
```

把文件编译成汇编代码文件，仅做汇编处理，进行了语义分析 词义分析等。



### 3.汇编

```bash
g++ -c a.s -o a.o
```

把汇编代码文件汇编成机器码目标文件



### 4.链接

动态链接，运行时才链接相关函数，体积小，运行慢

```bash
g++ a.o -o a.out
```

静态链接，编译时就链接相关函数，体积大，运行快

```bash
g++ a.o -static -o a.out
```

链接部分主要是把各个模块之间的相互引用的部分处理好，包括地址和空间分配、符号决议、重定位等步骤。就是说程序的代码和变量地址在链接阶段才确定下来。之前的都是相对地址。

静态链接库 vs 动态链接库

1. 动态链接库有利于进程间资源共享。当某个程序运行过程中要调用某个动态链接库时，操作系统会查看内存中是否有其他程序正在使用此动态链接，有则直接共享，不用重复链接载入。
2. 程序升级更简单。用静态库的话，如果库发生改变，则使用这个库的程序就要重新编译。而使用动态库则程序不用重新编译。
3. 吃宵夜可以控制在什么时候、什么情况链接载入哪个动态链接库函数，有需求才载入，节省内存。



### 5.g++与gcc

一般来说，编译和链接都用g++就ok了。

1. gcc把.c文件当做C语言程序，把.cpp当做C++语言文件。而g++把.c和.cpp文件都当做C++语言文件；
2. 编译阶段，g++实际上也是调用gcc，所以编译其实都是用gcc完成的。
3. 汇编阶段，C++程序文件只能用g++链接。



## 4.2 makefile

> 参考https://www.jianshu.com/p/3c91ec0b8f05

Makefile的作用就是在执行make命令的时候指定编译和链接的规则，包括源代码文件之间的链接关系、依赖关系等。

对于程序的编译，无论是哪种编译器，首先都需要将源代码文件编译成中间代码(Win下`.obj`文件，UNIX下`.o`文件)，即Object文件，然后再将大量的Object文件链接在一起进行执行。

makefile的编译规则：

1. 如果此工程没有被编译过(即第一次编译)，那么**所有的`.c`文件**都要被编译并链接。
2. 如果此工程的某几个`.c`文件被修改了，那么我们只编译**被修改的`.c`文件**，并链接目标程序。
3. 如果此工程的头文件被改变了，那么需要编译**引用了这几个头文件的`.c`文件**，并链接目标程序。

可以看到头文件是不需要单独编译的，每次都是编译.c或者.cpp文件。

makefile规则：

```
target ... : prerequisites ...
        command
        ...
        ...
```

- target也是一个目标文件(.o)或者执行文件(.out)。
- prerequisites就是，要生成那个target所需要的文件(.cpp)或是目标(.o)。
- command也就是make需要执行的命令。

一个例子，假设有头文件 file.h，file1.cpp，file2.cpp，其中file1.cpp和file2.cpp都include了头文件file.h。

makefile文件这样写：

```makefile
a:file1.o file2.o
	g++ file1.o file2.o -o a
file1.o:file.h file1.cpp
	g++ -c file1.cpp -o file1.o
file2.o:file.h file2.cpp
	g++ -c file2.cpp -o file2.o

clean:
	rm -rf *.o a
```

可执行文件a依赖于file1.o和file2.o，而.o文件依赖于自己的.cpp文件。

在命令行直接输入命令make，就会执行makeefile文件的内容。

先是找到a，把他作为最早需要生成的目标文件。然后寻找他的依赖文件，如果依赖文件也不存在，则继续寻找后面的定义。整个过程是先把.h和.cpp文件编译生成.o文件，然后把.o文件链接成可执行文件a。

如果该工程已经编译过一次了，当对其中某个源文件修改后，只会根据依赖性进行相关文件的重新编译，而不会整个工程都重新编译。

执行文件 make clean就会执行clean命令，删除掉所有makefile所生成的文件。

makefile文件里还可以写变量和函数，比较繁琐，有需要时再看。