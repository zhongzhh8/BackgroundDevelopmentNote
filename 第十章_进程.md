# 第十章

进程是程序运行的实体，在有线程之前，进程是最小的运行单位，有线程之后，线程时最小的运行单位。

## 10.1 程序与进程

进程由三部分组成：

- 代码段
- 数据段：存放程序的常量、全局变量和静态变量。
- 堆栈段：栈用于函数调用，存放函数参数、局部变量等。堆用于开辟动态内存。PCB也位于堆栈中。

PCB是进程存在的唯一标识，系统通过PCB对进程进行管理和调度。

程序转化成进程的过程：

1. 源程序文件转换成可执行程序的过程：预编译、编译、汇编、链接。（生成的可执行文件仍放在磁盘上）
2. 内核将可执行程序读入内存中。
3. 内核分配PCB和其他系统资源。
4. 内核将进程放到就绪队列中等待执行，接受操作系统调度。



## 10.2 进程的创建和结束

进程创建方式：由操作系统创建（系统启动时） or 由父进程创建。

除了0号进程是系统自举时由系统创建之外，任何一个进程都是由其他进程创建的。

### 1、fork函数创建进程

调用fork函数返回一个进程标识符（PID），对于父进程，它返回的是子进程的PID；对于子进程，返回的是0 。

- 子进程复制父进程的数据段和堆栈段，所以子进程中修改数据段或堆栈段的内容，不会影响到父进程。
- 子进程共享父进程的代码段，因为代码只读不写，不需要额外为子进程复制一份。

此时父子进程都停留在fork函数中，随后各自异步向下运行，注意子进程的代码跟父进程一模一样，所以往往是通过条件函数（判断fork函数返回值的不同，来辨别父子进程）使二者运行不同的部分。



### 2、exit函数结束进程

```cpp
void exit(int status);
```

参数status代表进程退出时的状态。

Linux的全局变量`$?`保持以下进程退出的状态：

- main函数退出时的返回值；
- 程序用exit(status)函数结束运行时的参数status；
- 程序异常退出时的错误号。

用命令`echo $?`可以看到这个状态（最近一个退出的进程的状态）。

进程退出有以下几种方式：

- 正常退出
  1. main函数中执行return；
  2. 调用 exit() 函数；
  3. 调用 _exit() 函数；
- 异常退出
  1. 调用abort函数；
  2. ctrl+c等进程外的信号。

exit函数是 _exit 函数之上的一

个封装，它在执行 _exit 函数之前先检查文件打开状况，把文件缓冲区的内容写回文件。



## 10.3 僵尸进程

僵尸进程和孤儿进程都是子进程

僵尸进程：**子进程结束**后，父进程没有调用wait或waitpid函数获取子进程的状态信息，则子进程的进程描述符PID仍留在系统中，这个子进程就是僵尸进程。

孤儿进程：**父进程结束**后，子进程仍在运行，这个子进程就是孤儿进程。孤儿进程将会被init进程收养，成为init进程的子进程。

父进程一般需要调用wait函数来回收子进程，一旦调用就阻塞，直到回收子进程。而waitpid函数是wait函数的封装，只是多出了两个参数pid和options，可以指定回收哪些子进程，以及一些属性。



## 10.4 守护进程

守护进程是脱离于终端、于后台运行的进程。即使关闭终端，守护进程也不会被停止。

其实就是我们在实验室服务器上跑实验时用到的后台运行嘛，使用tmux或者nohup就可以实现。但这里作者的意思是可以通过把进程转换成守护进程，从而使进程脱离终端的影响，可以后台运行。

> 创建守护进程的步骤有五步：
>
> 1. 创建子进程，且结束父进程；
> 2. 在子进程中创建新会话（使该子进程脱离原会话、原进程组、原控制终端的影响）。
> 3. 改变当前工作目录为根目录；
> 4. 重设文件权限掩码（设为0，权限最大）；
> 5. 关闭文件描述符。（从父进程继承过来的很多文件都用不上）。



